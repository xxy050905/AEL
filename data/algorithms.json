[
    {
        "id": 1,
        "description": "随机最近邻算法（90%概率选择最近节点，10%随机探索）",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    import random\n    if random.random() < 0.1 and len(unvisited_nodes) > 1:\n        return random.choice(unvisited_nodes)\n    min_dist = float('inf')\n    nearest = unvisited_nodes[0]\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_dist:\n            min_dist = distance_matrix[current_node][node]\n            nearest = node\n    return nearest"
    },
    {
        "id": 2,
        "description": "最大最小距离平衡算法（平衡当前距离与后续最小距离）",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = -float('inf')\n    best_node = unvisited_nodes[0]\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        if current_dist <= 1e-10:\n            current_dist = 1e-10 \n        future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        min_future_dist = min(future_distances) if future_distances else float('inf')\n        if min_future_dist <= 1e-10:\n            min_future_dist = 1e-10  \n        score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist)\n        if score > best_score:\n            best_score = score\n            best_node = node\n    return best_node"
    },
    {
        "id": 3,
        "description": "节点密度优先算法（优先访问高密度区域）",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    import numpy as np\n    density_scores = []\n    for node in unvisited_nodes:\n        distances = distance_matrix[node]\n        radius = np.percentile(distances, 25)\n        density = sum(1 for d in distances if d <= radius)\n        density_scores.append(density)\n    max_density = max(density_scores)\n    candidates = [n for n, s in zip(unvisited_nodes, density_scores) if s == max_density]\n    return min(candidates, key=lambda x: distance_matrix[current_node][x])"
    },
    {
        "id": 4,
        "description": "动态阶段选择算法（前期探索后期收敛）",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    total_nodes = len(distance_matrix)\n    visited_ratio = 1 - len(unvisited_nodes)/total_nodes \n    if visited_ratio < 0.7:\n        best_node = None\n        max_score = -float('inf')\n        for node in unvisited_nodes:\n            valid_neighbors = sum(1 for n in unvisited_nodes \n                                 if n != node and distance_matrix[node][n] < distance_matrix[current_node][node])\n            current_dist = distance_matrix[current_node][node]\n            score = valid_neighbors * 100 + (1 / current_dist if current_dist != 0 else float('inf'))\n            if score > max_score or (score == max_score and \n                                    distance_matrix[node][destination_node] < distance_matrix[best_node][destination_node]):\n                max_score = score\n                best_node = node\n        return best_node\n    else:\n        return min(unvisited_nodes, \n                   key=lambda x: (distance_matrix[current_node][x] + \n                                  0.3 * distance_matrix[x][destination_node]))"
    },
    {
        "id": 5,
        "description": "反向路径感知算法（考虑前进和返回路径影响）",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes[0]\n    min_cost = float('inf')\n    best_node = unvisited_nodes[0]\n    for node in unvisited_nodes:\n        forward_cost = distance_matrix[current_node][node]\n        return_cost = distance_matrix[node][destination_node]\n        remaining_cost = min(distance_matrix[node][n] for n in unvisited_nodes if n != node)\n        total = forward_cost + 0.4*return_cost + 0.6*remaining_cost\n        if total < min_cost:\n            min_cost = total\n            best_node = node\n    return best_node"
    },
    {
        "id": 6,
        "description": "动态平衡选择算法",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = -float('inf')\n    best_node = unvisited_nodes[0]\n    visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n    if visited_ratio < 0.7:\n        best_score = -float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            current_dist = distance_matrix[current_node][node]\n            if current_dist <= 1e-10:\n                current_dist = 1e-10\n            future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            min_future_dist = min(future_distances) if future_distances else float('inf')\n            if min_future_dist <= 1e-10:\n                min_future_dist = 1e-10\n            score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist)\n            if score > best_score:\n                best_score = score\n                best_node = node\n    else:\n        return min(unvisited_nodes,\n                   key=lambda x: (distance_matrix[current_node][x] +\n 0.3 * distance_matrix[x][destination_node]))\n    return best_node"
    },
    {
        "id": 7,
        "description": "优先选择最近且密度高的节点",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    import numpy as np\n    distances = distance_matrix[current_node]\n    density = np.zeros_like(distances)\n    for node in unvisited_nodes:\n        neighbor_dists = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        density[node] = 1/(np.mean(neighbor_dists) + 1e-9)\n    norm_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-9)\n    norm_density = (density - np.min(density)) / (np.max(density) - np.min(density) + 1e-9)\n    scores = 0.7 * (1 - norm_dist) + 0.3 * norm_density  # 距离越近、密度越高得分越高\n    best_node = unvisited_nodes[np.argmax([scores[node] for node in unvisited_nodes])]\n    return best_node"
    },
    {
        "id": 8,
        "description": "Node density based algorithm",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        # Step 1: Calculate distance-based scores\n        distances = distance_matrix[current_node]\n        distance_scores = [distances[i] for i in unvisited_nodes]\n    \n        # Step 2: Calculate density-based scores\n        density_scores = []\n        for node in unvisited_nodes:\n            distances_to_node = [distance_matrix[node][m] for m in unvisited_nodes]\n            radius = np.percentile(distances_to_node, 25)\n            density = sum(1 for d in distances_to_node if d <= radius)\n            density_scores.append(density)\n    \n        # Step 3: Combine distance and density scores with weights\n        weight_distance = 0.6\n        weight_density = 0.4\n        combined_scores = []\n        for i in range(len(unvisited_nodes)):\n            combined_score = weight_distance * distance_scores[i] + weight_density * density_scores[i]\n            combined_scores.append(combined_score)\n    \n        # Step 4: Select the next node with the minimum combined score\n        next_node = unvisited_nodes[np.argmin(combined_scores)]\n        return next_node"
    },
    {
        "id": 9,
        "description": "Modified nearest neighbor algorithm with dynamic weighting based on distance and density",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        # Calculate the distance from current_node to each unvisited node\n        distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n    \n        # Calculate the density (number of nodes within a certain distance) for each unvisited node\n        density_threshold = 30  # Nodes within this distance contribute to density\n        density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n    \n        # Calculate the weighted score for each unvisited node\n        scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n    \n        # Find the unvisited node with the minimum score\n        best_node = unvisited_nodes[np.argmin(scores)]\n    \n        return best_node"
    },
    {
        "id": 10,
        "description": "Dynamic weighting algorithm integrating distance and density",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        distances = distance_matrix[current_node]\n        densities = [len([n for n in unvisited_nodes if distance_matrix[n][m] < 30]) for m in unvisited_nodes]\n        scores = [0.6*distances[i] + 0.4*densities[i] for i in range(len(unvisited_nodes))]\n        return unvisited_nodes[np.argmin(scores)]"
    },
    {
        "id": 11,
        "description": "Combined density and minimum distance algorithm",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        density_scores = []\n        min_distances = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n            min_distances.append(min(distances))\n        scores = [0.5 * density + 0.5 * min_distance for density, min_distance in zip(density_scores, min_distances)]\n        return unvisited_nodes[np.argmax(scores)]"
    },
    {
        "id": 12,
        "description": "Combined Approach: The new algorithm combines the strengths of both algorithms by first evaluating the immediate proximity to the destination and then considering the overall path efficiency. It dynamically adjusts the weight given to each factor based on the number of unvisited nodes, ensuring a balance between local and global optimization.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        total_nodes = len(distance_matrix)\n        visited_ratio = 1 - len(unvisited_nodes)/total_nodes \n        if visited_ratio < 0.7:\n            # Use Algorithm 1's approach for exploration phase\n            best_node = None\n            max_score = -float('inf')\n            for node in unvisited_nodes:\n                valid_neighbors = sum(1 for n in unvisited_nodes \n                                     if n != node and distance_matrix[node][n] < distance_matrix[current_node][node])\n                current_dist = distance_matrix[current_node][node]\n                score = valid_neighbors * 100 + (1 / current_dist if current_dist != 0 else float('inf'))\n                if score > max_score or (score == max_score and \n     distance_matrix[node][destination_node] < distance_matrix[best_node][destination_node]):\n                    max_score = score\n                    best_node = node\n            return best_node\n        else:\n            # Use Algorithm 2's approach for convergence phase\n            best_score = -float('inf')\n            best_node = unvisited_nodes[0]\n            for node in unvisited_nodes:\n                current_dist = distance_matrix[current_node][node]\n                if current_dist <= 1e-10:\n                    current_dist = 1e-10\n                future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n                min_future_dist = min(future_distances) if future_distances else float('inf')\n                if min_future_dist <= 1e-10:\n                    min_future_dist = 1e-10\n                score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist)\n                if score > best_score:\n                    best_score = score\n                    best_node = node\n            return best_node"
    },
    {
        "id": 13,
        "description": "Hybrid algorithm that combines node density and dynamic phase selection. It first evaluates node density to identify clusters and then uses dynamic phase selection to choose the next node based on proximity to the destination node and cluster density.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate density scores for each unvisited node\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Calculate scores based on density and proximity to destination\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            score = density_score * 0.5 + proximity_score * 0.5\n            scores.append(score)\n        # Select the node with the highest score\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 14,
        "description": "Density-based priority with adaptive weighting",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate density scores for each unvisited node\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Calculate scores based on density and proximity to destination\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            # Adaptive weighting based on remaining nodes\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.1 * remaining)\n            weight_proximity = 0.5 - (0.1 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            scores.append(score)\n        # Select the node with the highest score\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 15,
        "description": "The new algorithm is motivated by both algorithms. It uses a combination of the maximum-min distance and node density to select the next node. It calculates the maximum-min distance for each node and the node density, then combines them with weights to determine the best next node.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        best_score = -float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            current_dist = distance_matrix[current_node][node]\n            if current_dist <= 1e-10:\n                current_dist = 1e-10 \n            future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            min_future_dist = min(future_distances) if future_distances else float('inf')\n            if min_future_dist <= 1e-10:\n                min_future_dist = 1e-10  \n            # Calculate node density\n            distances_to_node = [distance_matrix[node][m] for m in unvisited_nodes]\n            radius = np.percentile(distances_to_node, 25)\n            density = sum(1 for d in distances_to_node if d <= radius)\n            score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist) + 0.2 * density\n            if score > best_score:\n                best_score = score\n                best_node = node\n        return best_node"
    },
    {
        "id": 16,
        "description": "Algorithm that combines the strengths of both algorithms by using dynamic weighting based on the visited ratio and node density",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        total_nodes = len(distance_matrix)\n        visited_ratio = 1 - len(unvisited_nodes)/total_nodes \n        if visited_ratio < 0.7:\n            # Use Algorithm 1's approach for early stages\n            best_node = None\n            max_score = -float('inf')\n            for node in unvisited_nodes:\n                valid_neighbors = sum(1 for n in unvisited_nodes \n                                     if n != node and distance_matrix[node][n] < distance_matrix[current_node][node])\n                current_dist = distance_matrix[current_node][node]\n                score = valid_neighbors * 100 + (1 / current_dist if current_dist != 0 else float('inf'))\n                if score > max_score or (score == max_score and \n     distance_matrix[node][destination_node] < distance_matrix[best_node][destination_node]):\n                    max_score = score\n                    best_node = node\n            return best_node\n        else:\n            # Use Algorithm 2's approach for later stages\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            density_threshold = 30  # Nodes within this distance contribute to density\n            density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n            scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n            best_node = unvisited_nodes[np.argmin(scores)]\n            return best_node"
    },
    {
        "id": 17,
        "description": "Combined algorithm that uses both distance and density scores, but with a dynamic weight adjustment based on the number of visited nodes. The weight of distance increases as more nodes are visited.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        # Step 1: Calculate distance-based scores\n        distances = distance_matrix[current_node]\n        distance_scores = [distances[i] for i in unvisited_nodes]\n    \n        # Step 2: Calculate density-based scores\n        density_scores = []\n        for node in unvisited_nodes:\n            distances_to_node = [distance_matrix[node][m] for m in unvisited_nodes]\n            radius = np.percentile(distances_to_node, 25)\n            density = sum(1 for d in distances_to_node if d <= radius)\n            density_scores.append(density)\n    \n        # Step 3: Adjust weights based on visited ratio\n        visited_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight_distance = 0.6 + 0.2 * visited_ratio\n        weight_density = 0.4 - 0.2 * visited_ratio\n    \n        # Step 4: Combine distance and density scores with weights\n        combined_scores = []\n        for i in range(len(unvisited_nodes)):\n            combined_score = weight_distance * distance_scores[i] + weight_density * density_scores[i]\n            combined_scores.append(combined_score)\n    \n        # Step 5: Select the next node with the minimum combined score\n        next_node = unvisited_nodes[np.argmin(combined_scores)]\n        return next_node"
    },
    {
        "id": 18,
        "description": "The new algorithm is a hybrid approach that combines the nearest neighbor and density-based selection. It first selects the nearest node, then adjusts the selection based on the density of nodes in the vicinity to ensure a balance between proximity and coverage.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n        nearest_node = unvisited_nodes[np.argmin(distances)]\n        # Calculate density around nearest_node\n        density = [len([n for n in unvisited_nodes if distance_matrix[n][nearest_node] < 30]) for _ in distances]\n        # Adjust the nearest node selection based on density\n        adjusted_score = [distances[i] + density[i] for i in range(len(distances))]\n        next_node = unvisited_nodes[np.argmin(adjusted_score)]\n        return next_node"
    },
    {
        "id": 19,
        "description": "Combined algorithm that uses dynamic balancing between nearest neighbor and density-based selection, with a dynamic weighting factor that adjusts based on the number of unvisited nodes remaining",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n        if visited_ratio < 0.5:\n            # Use Algorithm 1's approach for early stages\n            best_score = -float('inf')\n            best_node = unvisited_nodes[0]\n            for node in unvisited_nodes:\n                current_dist = distance_matrix[current_node][node]\n                if current_dist <= 1e-10:\n                    current_dist = 1e-10\n                future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n                min_future_dist = min(future_distances) if future_distances else float('inf')\n                if min_future_dist <= 1e-10:\n                    min_future_dist = 1e-10\n                score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist)\n                if score > best_score:\n                    best_score = score\n                    best_node = node\n            return best_node\n        else:\n            # Use Algorithm 2's approach for later stages\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            density_threshold = 30  # Nodes within this distance contribute to density\n            density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n            scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n            best_node = unvisited_nodes[np.argmin(scores)]\n            return best_node"
    },
    {
        "id": 20,
        "description": "Hybrid algorithm that combines the strengths of both algorithms by using a dynamic selection based on the number of visited nodes. In the early stages, it prioritizes nodes with higher potential for future connections, similar to Algorithm 2, while in the later stages, it employs a greedy approach similar to Algorithm 1 but with a focus on proximity to the destination node.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        total_nodes = len(distance_matrix)\n        visited_ratio = 1 - len(unvisited_nodes)/total_nodes \n        if visited_ratio < 0.5:\n            # Early stage: prioritize nodes with higher potential for future connections\n            best_node = None\n            max_score = -float('inf')\n            for node in unvisited_nodes:\n                valid_neighbors = sum(1 for n in unvisited_nodes \n                                     if n != node and distance_matrix[node][n] < distance_matrix[current_node][node])\n                current_dist = distance_matrix[current_node][node]\n                score = valid_neighbors * 100 + (1 / current_dist if current_dist != 0 else float('inf'))\n                if score > max_score or (score == max_score and \n     distance_matrix[node][destination_node] < distance_matrix[best_node][destination_node]):\n                    max_score = score\n                    best_node = node\n            return best_node\n        else:\n            # Late stage: focus on proximity to destination\n            return min(unvisited_nodes, \n                       key=lambda x: (distance_matrix[current_node][x] + \n     0.3 * distance_matrix[x][destination_node]))"
    },
    {
        "id": 21,
        "description": "Combined algorithm that uses both forward and backward path costs and node density",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        scores = []\n        for node in unvisited_nodes:\n            # Forward cost from current node to next node\n            forward_cost = distance_matrix[current_node][node]\n            # Backward cost from next node to destination\n            backward_cost = distance_matrix[node][destination_node]\n            # Density score based on proximity to other nodes\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            # Combine the scores with weights\n            score = forward_cost + 0.3*backward_cost + 0.7*density\n            scores.append(score)\n        # Select the node with the minimum score\n        return unvisited_nodes[np.argmin(scores)]"
    },
    {
        "id": 22,
        "description": "The new algorithm is a modified nearest neighbor that uses a dynamic weighting based on distance and density. It calculates the distance from the current node to each unvisited node and the density of nodes within a certain distance. Then, it assigns weights to each node based on these two factors and selects the node with the minimum weighted score.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n        density_threshold = 30\n        density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n        scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n        best_node = unvisited_nodes[np.argmin(scores)]\n        return best_node"
    },
    {
        "id": 23,
        "description": "The new algorithm combines the nearest neighbor approach with dynamic weighting based on both distance and node density, similar to Algorithm 1, but introduces a phase-based selection where in the early stages, it prioritizes nodes with higher connectivity potential, and in later stages, it focuses on minimizing the remaining path distance, inspired by Algorithm 2.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        total_nodes = len(distance_matrix)\n        visited_ratio = 1 - len(unvisited_nodes)/total_nodes \n        if visited_ratio < 0.7:\n            # Early phase: prioritize nodes with higher connectivity potential\n            best_node = None\n            max_score = -float('inf')\n            for node in unvisited_nodes:\n                # Calculate the number of nodes within a certain distance that can be connected through this node\n                connectivity = sum(1 for n in unvisited_nodes \n                                  if n != node and distance_matrix[n][node] < distance_matrix[n][current_node])\n                current_dist = distance_matrix[current_node][node]\n                score = connectivity * 100 + (1 / current_dist if current_dist != 0 else float('inf'))\n                if score > max_score or (score == max_score and \n     distance_matrix[node][destination_node] < distance_matrix[best_node][destination_node]):\n                    max_score = score\n                    best_node = node\n            return best_node\n        else:\n            # Late phase: focus on minimizing the remaining path distance\n            return min(unvisited_nodes, \n                       key=lambda x: (distance_matrix[current_node][x] + \n     0.3 * distance_matrix[x][destination_node]))"
    },
    {
        "id": 24,
        "description": "The new algorithm is a hybrid approach that integrates node density and dynamic balancing. It first assesses the density of nodes to identify clusters, then dynamically balances between proximity to the destination and cluster density to select the next node.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate density scores for each unvisited node\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Calculate scores based on density and proximity to destination\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            score = density_score * 0.5 + proximity_score * 0.5\n            scores.append(score)\n        # Select the node with the highest score\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 25,
        "description": "Algorithm integrates both forward and backward path costs with dynamic weights based on remaining nodes",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if len(unvisited_nodes) == 1:\n            return unvisited_nodes[0]\n        min_cost = float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            forward_cost = distance_matrix[current_node][node]\n            return_cost = distance_matrix[node][destination_node]\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            remaining_cost = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0\n            total = forward_cost + 0.4*return_cost + 0.6*remaining_cost\n            if total < min_cost:\n                min_cost = total\n                best_node = node\n        return best_node"
    },
    {
        "id": 26,
        "description": "Hybrid approach combining density-based priority and random exploration by incorporating a dynamic weighting factor that increases the influence of density-based selection as the number of remaining nodes decreases, while occasionally allowing for random jumps to escape local optima",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate density scores for each unvisited node\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Calculate scores based on density and proximity to destination\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            # Dynamic weighting based on remaining nodes\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.1 * remaining)\n            weight_proximity = 0.5 - (0.1 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            scores.append(score)\n        # Select the node with the highest score\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 27,
        "description": "The new algorithm considers both the forward path from the current node to the next node and the backward path from the next node to the destination node, similar to Algorithm 1. Additionally, it incorporates a density-based approach to prefer nodes that are part of dense regions, similar to Algorithm 2. The algorithm calculates a combined score for each candidate node, which is a weighted sum of the forward cost, return cost, and the density score of the node. The node with the minimum combined score is selected as the next node.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if len(unvisited_nodes) == 1:\n            return unvisited_nodes[0]\n        min_cost = float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            forward_cost = distance_matrix[current_node][node]\n            return_cost = distance_matrix[node][destination_node]\n            # Calculate density score for the node\n            distances_to_node = [distance_matrix[node][m] for m in unvisited_nodes if m != node]\n            radius = np.percentile(distances_to_node, 25)\n            density = sum(1 for d in distances_to_node if d <= radius)\n            # Combine the scores with weights\n            total = forward_cost + 0.4*return_cost + 0.6*density\n            if total < min_cost:\n                min_cost = total\n                best_node = node\n        return best_node"
    },
    {
        "id": 28,
        "description": "The new algorithm uses a hybrid approach combining density-based priority and dynamic balancing. It calculates density scores to prioritize nodes in dense areas and adjusts the selection based on proximity to the destination and the remaining path's minimum distances. This ensures a balance between exploring clusters and efficiently reaching the destination.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.1 * remaining)\n            weight_proximity = 0.5 - (0.1 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            min_future_dist = min(future_distances) if future_distances else float('inf')\n            score += 0.2 * (1 / min_future_dist)\n            scores.append(score)\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 29,
        "description": "Modified algorithm with adaptive density and proximity scoring",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.15 * remaining)\n            weight_proximity = 0.5 - (0.15 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            min_future_dist = min(future_distances) if future_distances else float('inf')\n            score += 0.2 * (1 / min_future_dist)\n            scores.append(score)\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 30,
        "description": "Combined nearest neighbor and density-based selection with adaptive weights",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate nearest neighbor distance\n        nearest_dist = float('inf')\n        nearest_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < nearest_dist:\n                nearest_dist = distance_matrix[current_node][node]\n                nearest_node = node\n        # Calculate density scores\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Combine scores with adaptive weights\n        remaining = len(unvisited_nodes)\n        weight_nearest = 0.5 + (0.1 * remaining)\n        weight_density = 0.5 - (0.1 * remaining)\n        combined_scores = [distance_matrix[current_node][node] * weight_nearest + density_scores[i] * weight_density for i, node in enumerate(unvisited_nodes)]\n        # Select the best node\n        best_node = unvisited_nodes[np.argmin(combined_scores)]\n        return best_node"
    },
    {
        "id": 31,
        "description": "Modified algorithm with adaptive density and proximity scoring",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.15 * remaining)\n            weight_proximity = 0.5 - (0.15 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            min_future_dist = min(future_distances) if future_distances else float('inf')\n            score += 0.2 * (1 / min_future_dist)\n            scores.append(score)\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 32,
        "description": "The new algorithm calculates the harmonic mean of the current distance and the minimum future distance to select the next node. This approach balances the immediate benefit of a short current distance with the potential for longer-term benefits from shorter future distances.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        best_score = -float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            current_dist = distance_matrix[current_node][node]\n            if current_dist <= 1e-10:\n                current_dist = 1e-10 \n            future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            min_future_dist = min(future_distances) if future_distances else float('inf')\n            if min_future_dist <= 1e-10:\n                min_future_dist = 1e-10  \n            score = 2 * (current_dist + min_future_dist) / (current_dist * min_future_dist)\n            if score > best_score:\n                best_score = score\n                best_node = node\n        return best_node"
    },
    {
        "id": 33,
        "description": "Hybrid algorithm that combines node density and dynamic phase selection. It first evaluates node density to identify clusters and then uses dynamic phase selection to choose the next node based on proximity to the destination node and cluster density.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n            import numpy as np\n            if not unvisited_nodes:\n                return None\n            # Calculate density scores for each unvisited node\n            density_scores = []\n            for node in unvisited_nodes:\n                distances = distance_matrix[node]\n                radius = np.percentile(distances, 25)\n                density = sum(1 for d in distances if d <= radius)\n                density_scores.append(density)\n            # Calculate scores based on density and proximity to destination\n            scores = []\n            for node in unvisited_nodes:\n                density_score = density_scores[unvisited_nodes.index(node)]\n                proximity_score = distance_matrix[node][destination_node]\n                score = density_score * 0.5 + proximity_score * 0.5\n                scores.append(score)\n            # Select the node with the highest score\n            best_node = unvisited_nodes[scores.index(max(scores))]\n            return best_node"
    },
    {
        "id": 34,
        "description": "The new algorithm is a hybrid approach that combines the dynamic weighting of Algorithm 1 with the phase-based selection of Algorithm 2. It uses a weighted score that considers both distance and density during the exploration phase and switches to a greedy approach based on distance and destination proximity during the convergence phase.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        total_nodes = len(distance_matrix)\n        visited_ratio = 1 - len(unvisited_nodes)/total_nodes \n        if visited_ratio < 0.7:\n            # Exploration phase: use Algorithm 1's density and distance weighting\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            density_threshold = 30\n            density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n            scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n            best_node = unvisited_nodes[np.argmin(scores)]\n        else:\n            # Convergence phase: use Algorithm 2's greedy approach\n            return min(unvisited_nodes, \n                       key=lambda x: (distance_matrix[current_node][x] + \n     0.3 * distance_matrix[x][destination_node]))\n        return best_node"
    },
    {
        "id": 35,
        "description": "Algorithm 3 combines the strengths of both parent algorithms by incorporating density-based selection with an adaptive weighting system that considers proximity to the destination node. It first calculates density scores for each unvisited node, then assigns weights based on the remaining nodes, and finally selects the node with the highest combined score.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Adaptive weighting based on remaining nodes\n        remaining = len(unvisited_nodes)\n        weight_density = 0.5 + (0.1 * remaining)\n        weight_proximity = 0.5 - (0.1 * remaining)\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            score = density_score * weight_density + proximity_score * weight_proximity\n            scores.append(score)\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 36,
        "description": "The new algorithm is a hybrid approach that combines the strengths of both algorithms by first evaluating the immediate proximity to the destination and then considering the overall path efficiency. It dynamically adjusts the weight given to each factor based on the number of unvisited nodes, ensuring a balance between local and global optimization.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        total_nodes = len(distance_matrix)\n        visited_ratio = 1 - len(unvisited_nodes)/total_nodes\n        if visited_ratio < 0.7:\n            # Use Algorithm 1's approach for exploration phase\n            best_node = None\n            max_score = -float('inf')\n            for node in unvisited_nodes:\n                valid_neighbors = sum(1 for n in unvisited_nodes \n                                     if n != node and distance_matrix[node][n] < distance_matrix[current_node][node])\n                current_dist = distance_matrix[current_node][node]\n                score = valid_neighbors * 100 + (1 / current_dist if current_dist != 0 else float('inf'))\n                if score > max_score or (score == max_score and \n         distance_matrix[node][destination_node] < distance_matrix[best_node][destination_node]):\n                    max_score = score\n                    best_node = node\n            return best_node\n        else:\n            # Use Algorithm 2's approach for convergence phase\n            best_score = -float('inf')\n            best_node = unvisited_nodes[0]\n            for node in unvisited_nodes:\n                current_dist = distance_matrix[current_node][node]\n                if current_dist <= 1e-10:\n                    current_dist = 1e-10\n                future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n                min_future_dist = min(future_distances) if future_distances else float('inf')\n                if min_future_dist <= 1e-10:\n                    min_future_dist = 1e-10\n                score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist)\n                if score > best_score:\n                    best_score = score\n                    best_node = node\n            return best_node"
    },
    {
        "id": 37,
        "description": "Algorithm 3: 新算法结合了算法1和算法2的优点，通过多目标优化来选择下一个节点。它不仅考虑当前的距离和密度，还平衡了后续的最小距离，以实现整体路径的最优化。",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n                    # 算法3的实现代码\n                    import numpy as np\n                    distances = distance_matrix[current_node]\n                    density = np.zeros_like(distances)\n                    for node in unvisited_nodes:\n                        neighbor_dists = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n                        density[node] = 1/(np.mean(neighbor_dists) + 1e-9)\n                    norm_dist = (distances - np.min(distances)) / (np.max(distances) - np.min(distances) + 1e-9)\n                    norm_density = (density - np.min(density)) / (np.max(density) - np.min(density) + 1e-9)\n                    scores = 0.7 * (1 - norm_dist) + 0.3 * norm_density  # 距离越近、密度越高得分越高\n                    best_node = unvisited_nodes[np.argmax([scores[node] for node in unvisited_nodes])]\n                    return best_node"
    },
    {
        "id": 38,
        "description": "The new algorithm uses a hybrid approach combining both forward and backward path costs with dynamic weights based on the number of remaining nodes and the nearest neighbor distance. It calculates the forward cost, backward cost, and the average remaining cost, then combines them with adaptive weights that increase as the number of remaining nodes decreases. Additionally, it incorporates the nearest neighbor distance to further refine the selection.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if len(unvisited_nodes) == 1:\n            return unvisited_nodes[0]\n        min_cost = float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            forward_cost = distance_matrix[current_node][node]\n            backward_cost = distance_matrix[node][destination_node]\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            remaining_cost = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0\n            weight_forward = 0.5 + (0.1 * len(remaining_nodes))\n            weight_backward = 0.3 - (0.1 * len(remaining_nodes))\n            weight_remaining = 0.2 + (0.1 * len(remaining_nodes))\n            total = (forward_cost * weight_forward) + (backward_cost * weight_backward) + (remaining_cost * weight_remaining)\n            if total < min_cost:\n                min_cost = total\n                best_node = node\n        return best_node\n\n"
    },
    {
        "id": 39,
        "description": "The new algorithm is a modified nearest neighbor that uses a dynamic weighting based on distance and density. It calculates the distance from the current node to each unvisited node and the density of nodes within a certain distance. Then, it assigns weights to each node based on these two factors and selects the node with the minimum weighted score.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n        density_threshold = 30\n        density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n        scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n        best_node = unvisited_nodes[np.argmin(scores)]\n        return best_node\n\n"
    },
    {
        "id": 40,
        "description": "Hybrid approach combining density-based priority and random exploration by incorporating a dynamic weighting factor that increases the density-based selection as the number of remaining nodes decreases, while occasionally allowing for random jumps to escape local optima",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate density scores for each unvisited node\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Calculate scores based on density and proximity to destination\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            # Dynamic weighting based on remaining nodes\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.1 * remaining)\n            weight_proximity = 0.5 - (0.1 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            scores.append(score)\n        # Select the node with the highest score\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node\n\n"
    },
    {
        "id": 41,
        "description": "Hybrid approach combining density-based priority and random exploration by incorporating a dynamic weighting factor that increases the influence of density-based selection as the number of remaining nodes decreases, while occasionally allowing for random jumps to escape local optima.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate density scores for each unvisited node\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Calculate scores based on density and proximity to destination\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            # Dynamic weighting based on remaining nodes\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.1 * remaining)\n            weight_proximity = 0.5 - (0.1 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            scores.append(score)\n        # Select the node with the highest score\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node\n\n"
    },
    {
        "id": 42,
        "description": "The new algorithm uses a hybrid approach combining dynamic weighting based on the visited ratio and node density, similar to Algorithm 1, but with an enhanced scoring mechanism that considers future steps and adaptively adjusts the weight of proximity and density based on the remaining path length, similar to Algorithm 2. It dynamically calculates the weights for each step, ensuring a balance between immediate proximity and long-term density benefits, while also considering the minimal future distances to optimize the overall route.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        total_nodes = len(distance_matrix)\n        visited_ratio = 1 - len(unvisited_nodes)/total_nodes \n        if visited_ratio < 0.7:\n            # Use Algorithm 1's approach for early stages\n            best_node = None\n            max_score = -float('inf')\n            for node in unvisited_nodes:\n                valid_neighbors = sum(1 for n in unvisited_nodes \n                                     if n != node and distance_matrix[node][n] < distance_matrix[current_node][node])\n                current_dist = distance_matrix[current_node][node]\n                score = valid_neighbors * 100 + (1 / current_dist if current_dist != 0 else float('inf'))\n                if score > max_score or (score == max_score and \n         distance_matrix[node][destination_node] < distance_matrix[best_node][destination_node]):\n                    max_score = score\n                    best_node = node\n            return best_node\n        else:\n            # Use Algorithm 2's approach for later stages\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            density_threshold = 30  # Nodes within this distance contribute to density\n            density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n            scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n            best_node = unvisited_nodes[np.argmin(scores)]\n            return best_node\n\n"
    },
    {
        "id": 43,
        "description": "The new algorithm combines the strengths of both parent algorithms by incorporating a dynamic weighting factor that adjusts based on the number of unvisited nodes remaining, similar to Algorithm 2, but also considers both forward and return path costs, similar to Algorithm 1. It uses a weighted sum of the nearest neighbor, the minimum remaining distance, and the return path cost, with weights that dynamically adjust based on the stage of the traversal.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if len(unvisited_nodes) == 1:\n            return unvisited_nodes[0]\n        min_cost = float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            forward_cost = distance_matrix[current_node][node]\n            return_cost = distance_matrix[node][destination_node]\n            remaining_cost = min(distance_matrix[node][n] for n in unvisited_nodes if n != node)\n            # Dynamic weighting based on the number of unvisited nodes\n            visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n            weight_forward = 0.5 + 0.5 * visited_ratio\n            weight_return = 0.3 + 0.2 * visited_ratio\n            weight_remaining = 0.2 - 0.1 * visited_ratio\n            total = (weight_forward * forward_cost) + (weight_return * return_cost) + (weight_remaining * remaining_cost)\n            if total < min_cost:\n                min_cost = total\n                best_node = node\n        return best_node\n\n"
    },
    {
        "id": 44,
        "description": "Modified algorithm combining density and dynamic proximity weighting with adaptive thresholds",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate density scores with adaptive threshold based on remaining nodes\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            # Adaptive threshold decreases as remaining nodes decrease\n            remaining = len(unvisited_nodes)\n            threshold = np.percentile(distances, 25) * (1 - 0.1 * (remaining / len(unvisited_nodes)))\n            density = sum(1 for d in distances if d <= threshold)\n            density_scores.append(density)\n        # Calculate scores with dynamic weighting and adaptive proximity\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            # Dynamic weights adjust based on remaining nodes and current proximity\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.15 * remaining) - (0.05 * proximity_score)\n            weight_proximity = 0.5 - (0.15 * remaining) + (0.05 * proximity_score)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            scores.append(score)\n        # Select node with highest score, breaking ties by proximity\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node"
    },
    {
        "id": 45,
        "description": "The new algorithm dynamically adjusts the balance between selecting the nearest neighbor and considering the overall density of unvisited nodes, using a weighted score that changes based on the number of remaining nodes. It prioritizes nodes that are closer and have higher density in the early stages, shifting towards a more balanced approach as more nodes are visited.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n        if visited_ratio < 0.5:\n            # Early stage: prioritize nearest neighbor\n            return min(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])\n        else:\n            # Late stage: consider density-based selection\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            density = [sum(1 for n in unvisited_nodes if distance_matrix[n][m] < 30) for m in unvisited_nodes]\n            scores = [0.6 * d + 0.4 * den for d, den in zip(distances, density)]\n            return unvisited_nodes[np.argmin(scores)]\n"
    },
    {
        "id": 46,
        "description": "Combined algorithm that uses dynamic balancing between nearest neighbor and density-based selection, with a dynamic weighting factor that adjusts based on the number of unvisited nodes remaining",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n            import numpy as np\n            visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n            if visited_ratio < 0.5:\n                # Use Algorithm 1's approach for early stages\n                best_score = -float('inf')\n                best_node = unvisited_nodes[0]\n                for node in unvisited_nodes:\n                    current_dist = distance_matrix[current_node][node]\n                    if current_dist <= 1e-10:\n                        current_dist = 1e-10\n                    future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n                    min_future_dist = min(future_distances) if future_distances else float('inf')\n                    if min_future_dist <= 1e-10:\n                        min_future_dist = 1e-10\n                    score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist)\n                    if score > best_score:\n                        best_score = score\n                        best_node = node\n                return best_node\n            else:\n                # Use Algorithm 2's approach for later stages\n                distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n                density_threshold = 30  # Nodes within this distance contribute to density\n                density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n                scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n                best_node = unvisited_nodes[np.argmin(scores)]\n                return best_node\n\n"
    },
    {
        "id": 47,
        "description": "The new algorithm is a modified nearest neighbor that uses a dynamic weighting based on distance and density. It calculates the distance from the current node to each unvisited node and the density of nodes within a certain distance. Then, it assigns weights to each node based on these two factors and selects the node with the minimum weighted score.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n        density_threshold = 30\n        density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n        scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n        best_node = unvisited_nodes[np.argmin(scores)]\n        return best_node\n\n"
    },
    {
        "id": 48,
        "description": "The new algorithm uses a hybrid approach that combines the strengths of both algorithms by dynamically adjusting the weights based on the number of unvisited nodes and their proximity to the destination.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        total_nodes = len(distance_matrix)\n        visited_ratio = 1 - len(unvisited_nodes)/total_nodes\n        if visited_ratio < 0.5:\n            # Early stage: prioritize nodes closer to the destination\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            scores = [d * 0.8 + (1 / d if d != 0 else float('inf')) * 0.2 for d in distances]\n            return unvisited_nodes[np.argmin(scores)]\n        else:\n            # Late stage: balance distance and node density\n            density_threshold = 30\n            densities = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            scores = [0.6 * d + 0.4 * den for d, den in zip(distances, densities)]\n            return unvisited_nodes[np.argmin(scores)]\n"
    },
    {
        "id": 49,
        "description": "The new algorithm considers both the forward path from the current node to the next node and the backward path from the next node to the destination node, similar to Algorithm 1. Additionally, it incorporates a density-based approach to prefer nodes that are part of dense regions, similar to Algorithm 2. The algorithm calculates a combined score for each candidate node, which is a weighted sum of the forward cost, return cost, and the density score of the node. The next node is selected based on the minimum combined score.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if len(unvisited_nodes) == 1:\n            return unvisited_nodes[0]\n        min_cost = float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            forward_cost = distance_matrix[current_node][node]\n            return_cost = distance_matrix[node][destination_node]\n            # Calculate density score for the node\n            distances_to_node = [distance_matrix[node][m] for m in unvisited_nodes if m != node]\n            radius = np.percentile(distances_to_node, 25)\n            density = sum(1 for d in distances_to_node if d <= radius)\n            # Combine scores with weights\n            total = forward_cost + 0.4*return_cost + 0.6*density\n            if total < min_cost:\n                min_cost = total\n                best_node = node\n        return best_node\n\n"
    },
    {
        "id": 50,
        "description": "The new algorithm is a combination of forward and backward path costs with dynamic weights based on remaining nodes and node density. It first evaluates node density to identify clusters and then selects the next node based on a weighted sum of forward path cost, backward path cost, and cluster density.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if len(unvisited_nodes) == 1:\n            return unvisited_nodes[0]\n        min_cost = float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            forward_cost = distance_matrix[current_node][node]\n            return_cost = distance_matrix[node][destination_node]\n            # Calculate cluster density for the node\n            cluster_density = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < np.mean(distance_matrix[node]))\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            remaining_cost = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0\n            total = forward_cost + 0.4*return_cost + 0.6*remaining_cost + 0.3*cluster_density\n            if total < min_cost:\n                min_cost = total\n                best_node = node\n        return best_node\n\n"
    },
    {
        "id": 51,
        "description": "The new algorithm uses a hybrid approach combining density-based priority and dynamic balancing. It calculates density scores to prioritize nodes in dense areas and adjusts the selection based on proximity to the destination and the remaining path's minimum distances. This ensures a balance between exploring clusters and efficiently reaching the destination.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.1 * remaining)\n            weight_proximity = 0.5 - (0.1 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            min_future_dist = min(future_distances) if future_distances else float('inf')\n            score += 0.2 * (1 / min_future_dist)\n            scores.append(score)\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node\n\n"
    },
    {
        "id": 52,
        "description": "The new algorithm uses a combination of the maximum-min distance and node density to select the next node. It calculates the maximum-min distance for each node and the node density, then combines them with weights to determine the best next node.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        best_score = -float('inf')\n        best_node = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            current_dist = distance_matrix[current_node][node]\n            if current_dist <= 1e-10:\n                current_dist = 1e-10 \n            future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            min_future_dist = min(future_distances) if future_distances else float('inf')\n            if min_future_dist <= 1e-10:\n                min_future_dist = 1e-10  \n            # Calculate node density\n            distances_to_node = [distance_matrix[node][m] for m in unvisited_nodes]\n            radius = np.percentile(distances_to_node, 25)\n            density = sum(1 for d in distances_to_node if d <= radius)\n            score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist) + 0.2 * density\n            if score > best_score:\n                best_score = score\n                best_node = node\n        return best_node\n\n"
    },
    {
        "id": 53,
        "description": "The new algorithm dynamically adjusts the balance between local and global search based on the number of unvisited nodes. It uses a weighted score that combines the immediate proximity to the destination and the density of unvisited nodes in the vicinity, ensuring efficient exploration and exploitation throughout the search process.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n        if visited_ratio < 0.5:\n            # Use Algorithm 1's approach for early stages\n            best_score = -float('inf')\n            best_node = unvisited_nodes[0]\n            for node in unvisited_nodes:\n                current_dist = distance_matrix[current_node][node]\n                if current_dist <= 1e-10:\n                    current_dist = 1e-10\n                future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n                min_future_dist = min(future_distances) if future_distances else float('inf')\n                if min_future_dist <= 1e-10:\n                    min_future_dist = 1e-10\n                score = 0.7 * (1 / current_dist) + 0.3 * (1 / min_future_dist)\n                if score > best_score:\n                    best_score = score\n                    best_node = node\n            return best_node\n        else:\n            # Use Algorithm 2's approach for later stages\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            density_threshold = 30  # Nodes within this distance contribute to density\n            density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n            scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n            best_node = unvisited_nodes[np.argmin(scores)]\n            return best_node\n\n"
    },
    {
        "id": 54,
        "description": "The new algorithm uses a hybrid approach combining density-based priority and dynamic balancing. It calculates density scores to prioritize nodes in dense areas and adjusts the selection based on proximity to the destination and the remaining path's minimum distances. This ensures a balance between exploring clusters and efficiently reaching the destination.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n                    import numpy as np\n                    if not unvisited_nodes:\n                        return None\n                    density_scores = []\n                    for node in unvisited_nodes:\n                        distances = distance_matrix[node]\n                        radius = np.percentile(distances, 25)\n                        density = sum(1 for d in distances if d <= radius)\n                        density_scores.append(density)\n                    scores = []\n                    for node in unvisited_nodes:\n                        density_score = density_scores[unvisited_nodes.index(node)]\n                        proximity_score = distance_matrix[node][destination_node]\n                        remaining = len(unvisited_nodes)\n                        weight_density = 0.5 + (0.1 * remaining)\n                        weight_proximity = 0.5 - (0.1 * remaining)\n                        score = density_score * weight_density + proximity_score * weight_proximity\n                        future_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n                        min_future_dist = min(future_distances) if future_distances else float('inf')\n                        score += 0.2 * (1 / min_future_dist)\n                        scores.append(score)\n                    best_node = unvisited_nodes[scores.index(max(scores))]\n                    return best_node\n\n"
    },
    {
        "id": 55,
        "description": "Combined density and minimum distance algorithm",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        density_scores = []\n        min_distances = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n            min_distances.append(min(distances))\n        scores = [0.5 * density + 0.5 * min_distance for density, min_distance in zip(density_scores, min_distances)]\n        return unvisited_nodes[np.argmax(scores)]\n"
    },
    {
        "id": 56,
        "description": "Hybrid approach combining random nearest neighbor and density-based priority with adaptive weighting. It first checks if a random node should be selected for exploration (10% chance), otherwise, it calculates density scores and proximity to destination, applies adaptive weights based on remaining nodes, and selects the node with the highest combined score.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        import random\n        if random.random() < 0.1 and len(unvisited_nodes) > 1:\n            return random.choice(unvisited_nodes)\n        # Calculate density scores for each unvisited node\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Calculate scores based on density and proximity to destination\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            # Adaptive weighting based on remaining nodes\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.1 * remaining)\n            weight_proximity = 0.5 - (0.1 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            scores.append(score)\n        # Select the node with the highest score\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node\n\n"
    },
    {
        "id": 57,
        "description": "The new algorithm combines the strengths of both parent algorithms by incorporating a dynamic weighting factor that adjusts based on the number of unvisited nodes and also considers both density and minimum distance. It prioritizes nodes that are closer and have higher density in the early stages, gradually shifting towards a balanced approach as more nodes are visited.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n        if visited_ratio < 0.5:\n            # Early stage: prioritize minimum distance and density\n            density_scores = []\n            min_distances = []\n            for node in unvisited_nodes:\n                distances = distance_matrix[node]\n                radius = np.percentile(distances, 25)\n                density = sum(1 for d in distances if d <= radius)\n                density_scores.append(density)\n                min_distances.append(min(distances))\n            scores = [0.5 * density + 0.5 * min_distance for density, min_distance in zip(density_scores, min_distances)]\n            return unvisited_nodes[np.argmax(scores)]\n        else:\n            # Late stage: balance between nearest neighbor and density-based selection\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            density_threshold = 30  # Nodes within this distance contribute to density\n            density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n            scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n            best_node = unvisited_nodes[np.argmin(scores)]\n            return best_node\n\n"
    },
    {
        "id": 58,
        "description": "Adaptive thresholding based on visited ratio",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n        if visited_ratio < 0.5:\n            # Early stage: prioritize minimum distance and density\n            density_scores = []\n            min_distances = []\n            for node in unvisited_nodes:\n                distances = distance_matrix[node]\n                radius = np.percentile(distances, 25)\n                density = sum(1 for d in distances if d <= radius)\n                density_scores.append(density)\n                min_distances.append(min(distances))\n            scores = [0.5 * density + 0.5 * min_distance for density, min_distance in zip(density_scores, min_distances)]\n            return unvisited_nodes[np.argmax(scores)]\n        else:\n            # Late stage: balance between nearest neighbor and density-based selection\n            distances = [distance_matrix[current_node][n] for n in unvisited_nodes]\n            # Adaptive threshold based on visited ratio\n            density_threshold = 30 * (1 + visited_ratio)\n            density = [len([n for n in unvisited_nodes if distance_matrix[n][m] < density_threshold]) for m in unvisited_nodes]\n            scores = [0.6 * distance + 0.4 * density for distance, density in zip(distances, density)]\n            best_node = unvisited_nodes[np.argmin(scores)]\n            return best_node"
    },
    {
        "id": 59,
        "description": "The new algorithm is motivated by the need to balance both local and global search in the TSP problem. It uses a two-step approach where it first selects nodes based on their proximity to the destination to encourage progress towards the target, and then adjusts the selection based on the node's overall density to ensure a good coverage of the graph. This hybrid approach aims to combine the benefits of greedy local search with the global perspective of density-based selection.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        if not unvisited_nodes:\n            return None\n        # Calculate density scores for each unvisited node\n        density_scores = []\n        for node in unvisited_nodes:\n            distances = distance_matrix[node]\n            radius = np.percentile(distances, 25)\n            density = sum(1 for d in distances if d <= radius)\n            density_scores.append(density)\n        # Calculate scores based on density and proximity to destination\n        scores = []\n        for node in unvisited_nodes:\n            density_score = density_scores[unvisited_nodes.index(node)]\n            proximity_score = distance_matrix[node][destination_node]\n            # Dynamic weighting based on remaining nodes\n            remaining = len(unvisited_nodes)\n            weight_density = 0.5 + (0.1 * remaining)\n            weight_proximity = 0.5 - (0.1 * remaining)\n            score = density_score * weight_density + proximity_score * weight_proximity\n            scores.append(score)\n        # Select the node with the highest score\n        best_node = unvisited_nodes[scores.index(max(scores))]\n        return best_node\n\n"
    },
    {
        "id": 60,
        "description": "Greedy algorithm that always selects the nearest unvisited node, ignoring other factors.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n        import numpy as np\n        min_dist = float('inf')\n        nearest = unvisited_nodes[0]\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_dist:\n                min_dist = distance_matrix[current_node][node]\n                nearest = node\n        return nearest\n\n"
    },
    {
        "id": 61,
        "description": "This algorithm uses a hybrid approach by combining the density-based priority with random exploration. It incorporates a dynamic weighting factor that increases the influence of density-based selection as the number of remaining nodes decreases, while occasionally allowing for random jumps to escape local optima.",
        "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n                    import numpy as np\n                    if not unvisited_nodes:\n                        return None\n                    # Calculate density scores for each unvisited node\n                    density_scores = []\n                    for node in unvisited_nodes:\n                        distances = distance_matrix[node]\n                        radius = np.percentile(distances, 25)\n                        density = sum(1 for d in distances if d <= radius)\n                        density_scores.append(density)\n                    # Calculate scores based on density and proximity to destination\n                    scores = []\n                    for node in unvisited_nodes:\n                        density_score = density_scores[unvisited_nodes.index(node)]\n                        proximity_score = distance_matrix[node][destination_node]\n                        # Dynamic weighting based on remaining nodes\n                        remaining = len(unvisited_nodes)\n                        weight_density = 0.5 + (0.1 * remaining)\n                        weight_proximity = 0.5 - (0.1 * remaining)\n                        score = density_score * weight_density + proximity_score * weight_proximity\n                        scores.append(score)\n                    # Select the node with the highest score\n                    best_node = unvisited_nodes[scores.index(max(scores))]\n                    return best_node\n\n"
    }
]